# 可能是一份最适合你的后端面试指南（部分内容前端同样适用）| 掘金技术征文 #

**本文系掘金首发，禁止转载哦！** 如果觉得文章内容不错的话，欢迎为我转身，啊！不对，是给我一个赞！点赞之后会有惊喜哦！

看本文之前，推荐给大家一个阿里云双11活动，真的非常非常非常推荐，对于新人阿里云真的是下血本了，建议阿里云新人一定一定一定不要错过。如果觉得这单纯是广告的话，你可以直接跳过看正文。

> 
> 
> 
> 阿里云双11最新活动（仅限阿里云新用户购买，老用户拉新用户可以获得返现红包，后续有机会平分百万红包），优惠力度非常非常非常大，另外加入拼团，后续还有机会平分100w红包！
> **目前我的战队已经有12位新人了，现在是折上5折了也就是1折购买！！！。** 划重点了： **1核2G云服务器1年仅需99.5元！！！1核2G云服务器3年仅需298.50元！！！一个月仅需8.2元**
> 该折扣仅限新人！这是我的拼团团队地址： [m.aliyun.com/act/team111…](
> https://link.juejin.im?target=https%3A%2F%2Fm.aliyun.com%2Fact%2Fteam1111%2F%23%2Fshare%3Fparams%3DN.FF7yxCciiM.hf47liqn
> ) ！
> 
> 

写本文之前，其实我自己已经开源了一个 [Java学习指南的文档]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSnailclimb%2FJavaGuide ) ，里面包含了一些基础知识和一些后端（偏 Java 方向）的知识。到目前为止收获了 6.1k star 以及 1.5 k fork，close 了 10个 pr 以及 10 个issue。开源只是为了让更多的人看到和参与进来，这样文档的正确性和质量才能很好的保证。毕竟，我个人能力、时间以及知识广度和深度有限，一份好的项目的诞生肯定离不开和其他人的共同努力。

另外，我个人觉得不论你是前端还是后端（部分内容可能会偏 Java 方向一点）都能从本文中学到东西。

**本人技术水平有限，欢迎各位指正！写的不好的话，请多见谅！**

# 目录 #

* [前言]( #111 )
* [一 简历该如何写]( #1 )

* 1.1 为什么说简历很重要？
* 1.2-这3点你必须知道
* 1.3-两大法则了解一
* 1.4-项目经历怎么写？
* 1.5-专业技能该怎么写？
* 1.6-开源程序员简历模板分享
* 1.7 其他的一些小tips

* [二  计算机网络常见面试点总结]( #2 )

* 计算机网络常见问题回顾
* 2.1 TCP、UDP 协议的区别
* 2.2 在浏览器中输入url地址 ->> 显示主页的过程
* 2.3 各种协议与HTTP协议之间的关系
* 2.4 HTTP长连接、短连接
* 2.5 TCP 三次握手和四次挥手

* [三 Linux]( #3 )

* 3.1-简单介绍一下-linux-文件系统？
* 3.2 一些常见的 Linux 命令了解吗？

* [四 MySQL]( #4 )

* 4.1 说说自己对于 MySQL 常见的两种存储引擎：MyISAM与InnoDB的理解
* 4.2 数据库索引了解吗？
* 4.3 对于大表的常见优化手段说一下

* [五 Redis]( #5 )

* 5.1 redis 简介
* 5.2 为什么要用 redis /为什么要用缓存
* 5.3 为什么要用 redis 而不用 map/guava 做缓存?
* 5.4 redis 和 memcached 的区别
* 5.5 redis 常见数据结构以及使用场景分析
* 5.6 redis 设置过期时间
* 5.7 redis 内存淘汰机制
* 5.8 redis 持久化机制（怎么保证 redis 挂掉之后再重启数据可以进行恢复）
* 5.9 缓存雪崩和缓存穿透问题解决方案
* 5.10 如何解决 Redis 的并发竞争 Key 问题
* 5.11 如何保证缓存与数据库双写时的数据一致性？

* [六 Java]( #6 )

* 6.1 Java 基础知识
* 6.2 Java 集合框架
* 6.3 Java多线程
* 6.4 Java虚拟机
* 6.5 设计模式

* [七 数据结构]( #7 )
* [八 算法]( #8 )

* 8.1 举个栗子（手写快排）

* [九 Spring]( #9 )

* 9.1 Spring Bean 的作用域
* 9.2 Spring 事务中的隔离级别
* 9.3 Spring 事务中的事务传播行为
* 9.4 AOP
* 9.5 IOC

* [十 实际场景题]( #10 )
* [写在最后]( #666 )

# 前言 #

不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 **我其实特别不喜欢那种临近考试就提前背啊记啊各种题的行为，非常反对！我觉得这种方法特别极端，而且在稍有一点经验的面试官面前是根本没有用的。建议大家还是一步一个脚印踏踏实实地走。**

**运筹帷幄之后，决胜千里之外！不打毫无准备的仗，我觉得大家可以先从下面几个方面来准备面试：**

* 自我介绍。（你可千万这样介绍：“我叫某某，性别，来自哪里，学校是那个，自己爱干什么”，记住：多说点简历上没有的，多说点自己哪里比别人强！）
* 自己面试中可能涉及哪些知识点、那些知识点是重点。
* 面试中哪些问题会被经常问到、面试中自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)
* 自己的简历该如何写。

**“80%的offer掌握在20%的人手中”** 这句话也不是不无道理的。决定你面试能否成功的因素中实力固然占有很大一部分比例，但是如果你的心态或者说运气不好的话，依然无法拿到满意的 offer。运气暂且不谈，就拿心态来说，千万不要因为面试失败而气馁或者说怀疑自己的能力，面试失败之后多总结一下失败的原因，后面你就会发现自己会越来越强大。

另外，大家要明确的很重要的几点是：

* **写在简历上的东西一定要慎重，这可能是面试官大量提问的地方；**
* **大部分应届生找工作的硬伤是没有工作经验或实习经历；**
* **将自己的项目经历完美的展示出来非常重要。**

笔主能力有限，如果有不对的地方或者和你想法不同的地方，敬请雅正、不舍赐教。

如果想了解我的更多信息，可以关注我的 [Github]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSnailclimb ) 或者微信公众号:"Java面试通关手册"。

# 一 简历该如何写 #

![程序员的简历之道](https://user-gold-cdn.xitu.io/2018/7/25/164cf5c26e88cbcd?imageView2/0/w/1280/h/960/ignore-error/1)

> 
> 
> 
> 俗话说的好：“工欲善其事，必先利其器”。准备一份好的简历对于能不能找到一份好工作起到了至关重要的作用。
> 
> 

### 1.1 为什么说简历很重要？ ###

假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。

假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。

另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。

### 1.2 这3点你必须知道 ###

* **大部分应届生找工作的硬伤是没有工作经验或实习经历；**
* **写在简历上的东西一定要慎重，这可能是面试官大量提问的地方；**
* **将自己的项目经历完美的展示出来非常重要。**

### 1.3 两大法则了解一下 ###

目前写简历的方式有两种普遍被认可，一种是 STAR， 一种是 FAB。

**STAR法则（Situation Task Action Result）：**

* **Situation：** 事情是在什么情况下发生；
* **Task:：** 你是如何明确你的任务的；
* **Action：** 针对这样的情况分析，你采用了什么行动方式；
* **Result：** 结果怎样，在这样的情况下你学习到了什么。

**FAB 法则（Feature Advantage Benefit）：**

* **Feature：** 是什么；
* **Advantage：** 比别人好在哪些地方；
* **Benefit：** 如果雇佣你，招聘方会得到什么好处。

### 1.4 项目经历怎么写？ ###

简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：

* 对项目整体设计的一个感受
* 在这个项目中你负责了什么、做了什么、担任了什么角色
* 从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用
* 另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。

### 1.5 专业技能该怎么写？ ###

先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写：

* Dubbo：精通
* Spring：精通
* Docker：掌握
* SOA分布式开发 ：掌握
* Spring Cloud:了解

### 1.6 开源程序员简历模板分享 ###

分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 。 Github地址： [github.com/geekcompany…]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgeekcompany%2FResumeSample )

如果想学如何用 Markdown 写简历写一份高质量简历，请看这里: [github.com/Snailclimb/…]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSnailclimb%2FJava-Guide%2Fblob%2Fmaster%2F%25E9%259D%25A2%25E8%25AF%2595%25E5%25BF%2585%25E5%25A4%2587%2F%25E6%2589%258B%25E6%258A%258A%25E6%2589%258B%25E6%2595%2599%25E4%25BD%25A0%25E7%2594%25A8Markdown%25E5%2586%2599%25E4%25B8%2580%25E4%25BB%25BD%25E9%25AB%2598%25E8%25B4%25A8%25E9%2587%258F%25E7%259A%2584%25E7%25AE%2580%25E5%258E%2586.md )

### 1.7 其他的一些小tips ###

* 尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。
* 注意排版（不需要花花绿绿的），尽量使用Markdown语法。
* 如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。
* 如果自己的Github比较活跃的话，写上去也会为你加分很多。
* 注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容
* 项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。
* 如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。
* 简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。

# 二 计算机网络常见面试点总结 #

![网络分层结构](https://user-gold-cdn.xitu.io/2018/9/22/165fe6bcb149f58c?imageView2/0/w/1280/h/960/ignore-error/1)

### 计算机网络常见问题回顾 ###

* TCP三次握手和四次挥手、
* 在浏览器中输入url地址->>显示主页的过程
* TCP 协议如何保证可靠传输
* HTTP和HTTPS的区别
* TCP、UDP协议的区别
* 常见的状态码。

下面列举几个常见问题的回答！

### 2.1 TCP、UDP 协议的区别 ###

![TCP、UDP协议的区别](https://user-gold-cdn.xitu.io/2018/4/19/162db5e97e9a9e01?imageView2/0/w/1280/h/960/ignore-error/1)

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

### 2.2 在浏览器中输入url地址 ->> 显示主页的过程 ###

百度好像最喜欢问这个问题。

> 
> 
> 
> 打开一个网页，整个过程会使用哪些协议
> 
> 

图片来源：《图解HTTP》

![状态码](https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageView2/0/w/1280/h/960/ignore-error/1)

总体来说分为以下几个过程:

* DNS解析
* TCP连接
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 连接结束

具体可以参考下面这篇文章：

* [segmentfault.com/a/119000000…]( https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000006879700 )

### 2.3 各种协议与HTTP协议之间的关系 ###

一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。

图片来源：《图解HTTP》

![各种协议与HTTP协议之间的关系](https://user-gold-cdn.xitu.io/2018/5/8/1633ead316d07713?imageView2/0/w/1280/h/960/ignore-error/1)

### 2.4 HTTP长连接、短连接 ###

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

` Connection:keep-alive 复制代码`

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

—— [《HTTP长连接、短连接究竟是什么？》]( https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fgotodsp%2Fp%2F6366163.html )

### 2.5 TCP 三次握手和四次挥手(面试常客) ###

为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。

**漫画图解：**

图片来源：《图解HTTP》

![TCP三次握手](https://user-gold-cdn.xitu.io/2018/5/8/1633e127396541f1?imageView2/0/w/1280/h/960/ignore-error/1)

**简单示意图：**

![TCP三次握手](https://user-gold-cdn.xitu.io/2018/5/8/1633e14233d95972?imageView2/0/w/1280/h/960/ignore-error/1)

* 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
* 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
* 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

> 
> 
> 
> **为什么要三次握手?**
> 
> 

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

> 
> 
> 
> **为什么要传回 SYN**
> 
> 

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

> 
> 
> 
> SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用
> SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符
> ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。
> ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。
> 
> 

* 

> 
> 
> 
> **传了 SYN,为啥还要传 ACK**
> 
> 

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。

![TCP四次挥手](https://user-gold-cdn.xitu.io/2018/5/8/1633e1676e2ac0a3?imageView2/0/w/1280/h/960/ignore-error/1)

断开一个 TCP 连接则需要“四次挥手”：

* 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
* 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
* 服务器-关闭与客户端的连接，发送一个FIN给客户端
* 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

> 
> 
> 
> **为什么要四次挥手**
> 
> 

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

上面讲的比较概括，推荐一篇讲的比较细致的文章：

* [blog.csdn.net/qzcsu/artic…]( https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fqzcsu%2Farticle%2Fdetails%2F72861891 )

# 三 Linux #

![Linux](https://user-gold-cdn.xitu.io/2018/7/3/1645eeb8e843f29d?imageView2/0/w/1280/h/960/ignore-error/1)

### 3.1 简单介绍一下 Linux 文件系统？ ###

> 
> 
> 
> **Linux文件系统简介**
> 
> 

**在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。**

也就是说在LINUX系统中有一个重要的概念： **一切都是文件** 。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。

> 
> 
> 
> **文件类型与目录结构**
> 
> 

**Linux支持5种文件类型 ：**

![文件类型](https://user-gold-cdn.xitu.io/2018/7/3/1645f1a7d64def1a?imageView2/0/w/1280/h/960/ignore-error/1)

**Linux的目录结构如下：**

Linux文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：

![Linux的目录结构](https://user-gold-cdn.xitu.io/2018/7/3/1645f1c65676caf6?imageView2/0/w/1280/h/960/ignore-error/1)

**常见目录说明：**

* **/bin：** 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；
* **/etc：** 存放系统管理和配置文件；
* **/home：** 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；
* **/usr ：** 用于存放系统应用程序；
* **/opt：** 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；
* **/proc：** 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；
* **/root：** 超级用户（系统管理员）的主目录（特权阶级^o^）；
* **/sbin:** 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；
* **/dev：** 用于存放设备文件；
* **/mnt：** 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；
* **/boot：** 存放用于系统引导时使用的各种文件；
* **/lib ：** 存放着和系统运行相关的库文件 ；
* **/tmp：** 用于存放各种临时文件，是公用的临时文件存储点；
* **/var：** 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；
* **/lost+found：** 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。

### 3.2 一些常见的 Linux 命令了解吗？ ###

> 
> 
> 
> **目录切换命令**
> 
> 

* **` cd usr` ：** 切换到该目录下usr目录
* **` cd ..（或cd../）` ：** 切换到上一层目录
* **` cd /` ：** 切换到系统根目录
* **` cd ~` ：** 切换到用户主目录
* **` cd -` ：** 切换到上一个所在目录

> 
> 
> 
> **目录的操作命令（增删改查）**
> 
> 

* 

**` mkdir 目录名称` ：** 增加目录

* 

**` ls或者ll`** （ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息

* 

**` find 目录 参数` ：** 寻找目录（查）

* 

**` mv 目录名称 新目录名称` ：** 修改目录的名称（改）

注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。

* 

**` mv 目录名称 目录的新位置` ：** 移动目录的位置---剪切（改）

注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。

* 

**` cp -r 目录名称 目录拷贝的目标位置` ：** 拷贝目录（改），-r代表递归拷贝

注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归

* 

**` rm [-rf] 目录` :** 删除目录（删）

注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用 ` rm -rf` 目录/文件/压缩包

> 
> 
> 
> **文件的操作命令（增删改查）**
> 
> 

* 

**` touch 文件名称` :** 文件的创建（增）

* 

**` cat/more/less/tail 文件名称`** 文件的查看（查）

* **` cat` ：** 只能显示最后一屏内容
* **` more` ：** 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看
* **` less` ：** 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看
* **` tail-10` ：** 查看文件的后10行，Ctrl+C结束

注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化

* 

**` vim 文件` ：** 修改文件的内容（改）

vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。

**在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：**

vim 文件------>进入文件----->命令模式------>按i进入编辑模式----->编辑文件 ------->按Esc进入底行模式----->输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）

* 

**` rm -rf 文件` ：** 删除文件（删）

同目录删除：熟记 ` rm -rf` 文件 即可

> 
> 
> 
> **压缩文件的操作命令**
> 
> 

**1）打包并压缩文件：**

Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。

而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令： **` tar -zcvf 打包压缩后的文件名 要打包压缩的文件`** 其中：

z：调用gzip压缩命令进行压缩

c：打包文件

v：显示运行过程

f：指定文件名

比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令： **` tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt` 或： ` tar -zcvf test.tar.gz /test/`**

**2）解压压缩包：**

命令：tar [-xvf] 压缩文件

其中：x：代表解压

示例：

1 将/test下的test.tar.gz解压到当前目录下可以使用命令： **` tar -xvf test.tar.gz`**

2 将/test下的test.tar.gz解压到根目录/usr下: **` tar -xvf xxx.tar.gz -C /usr`** （- C代表指定解压的位置）

> 
> 
> 
> **其他常用命令**
> 
> 

* 

**` pwd` ：** 显示当前所在位置

* 

**` grep 要搜索的字符串 要搜索的文件 --color` ：** 搜索命令，--color代表高亮显示

* 

**` ps -ef` / ` ps aux` ：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式： **` ps aux|grep redis`** （查看包括redis字符串的进程）

注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。

* 

**` kill -9 进程的pid` ：** 杀死进程（-9 表示强制终止。）

先用ps查找进程，然后用kill杀掉

* 

**网络通信命令：**

* 查看当前系统的网卡信息：ifconfig
* 查看与某台机器的连接情况：ping
* 查看当前系统的端口使用：netstat -an

* 

**` shutdown` ：** ` shutdown -h now` ： 指定现在立即关机； ` shutdown +5 "System will shutdown after 5 minutes"` :指定5分钟后关机，同时送出警告信息给登入用户。

* 

**` reboot` ：** **` reboot` ：** 重开机。 **` reboot -w` ：** 做个重开机的模拟（只有纪录并不会真的重开机）。

# 四 MySQL #

![MySQL](https://user-gold-cdn.xitu.io/2018/9/22/165fe6ecea2c6052?imageView2/0/w/1280/h/960/ignore-error/1)

### 4.1 说说自己对于 MySQL 常见的两种存储引擎：MyISAM与InnoDB的理解 ###

关于二者的对比与总结:

* **count运算上的区别** ：因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。
* **是否支持事务和崩溃后的安全恢复** ： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
* **是否支持外键** ： MyISAM不支持，而InnoDB支持。

MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。 一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务时，MyISAM是最好的选择。

### 4.2 数据库索引了解吗？ ###

Mysql索引使用的数据结构主要有BTree索引 和 哈希索引 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

Mysql的BTree索引使用的是B数中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。

* MyISAM: B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
* InnoDB: 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引（非聚集索引），辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》

另外，再推荐几篇比较好的关于索引的文章：

* [juejin.im/post/5b55b8…]( https://juejin.im/post/5b55b842f265da0f9e589e79#comment )
* [www.jianshu.com/p/1775b4ff1…]( https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1775b4ff123a )

### 4.3 对于大表的常见优化手段说一下 ###

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

* 

**限定数据的范围** ： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；

* 

**读/写分离** ： 经典的数据库拆分方案，主库负责写，从库负责读；

* 

**缓存** ： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；

* 

**垂直分区：**

**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。

![](https://user-gold-cdn.xitu.io/2018/6/16/164084354ba2e0fd?imageView2/0/w/1280/h/960/ignore-error/1)

**垂直拆分的优点：** 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。

**垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

* 

**水平分区：**

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

![数据库水平拆分](https://user-gold-cdn.xitu.io/2018/6/16/164084b7e9e423e3?imageView2/0/w/1280/h/960/ignore-error/1)

水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水品拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少** ，但 **分片事务难以解决** ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案：**

* **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。
* **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。

# 五 Redis #

![Redis](https://user-gold-cdn.xitu.io/2018/9/22/165fe86c63761990?imageView2/0/w/1280/h/960/ignore-error/1)

**关于 redis 必知必会的11个问题！后两个问题，暂未更新！如有需要，可以关注我的 Github 或者微信公众号：“Java面试通关手册”获取后续更新内容。**

* redis 简介
* 为什么要用 redis /为什么要用缓存
* 为什么要用 redis 而不用 map/guava 做缓存?
* redis 和 memcached 的区别
* redis 常见数据结构以及使用场景分析
* redis 设置过期时间
* redis 内存淘汰机制
* redis 持久化机制（怎么保证 redis 挂掉之后再重启数据可以进行恢复）
* 缓存雪崩和缓存穿透问题解决方案
* 如何解决 Redis 的并发竞争 Key 问题
* 如何保证缓存与数据库双写时的数据一致性？

### 5.1 redis 简介 ###

简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以存写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。

### 5.2 为什么要用 redis /为什么要用缓存 ###

主要从“高性能”和“高并发”这两点来看待这个问题。

**高性能：**

假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

![](https://user-gold-cdn.xitu.io/2018/9/25/1660ed15756061ef?imageView2/0/w/1280/h/960/ignore-error/1)

**高并发：**

直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

![](https://user-gold-cdn.xitu.io/2018/9/25/1660ed157643e87f?imageView2/0/w/1280/h/960/ignore-error/1)

### 5.3 为什么要用 redis 而不用 map/guava 做缓存? ###

> 
> 
> 
> 下面的内容来自 segmentfault 一位网友的提问，地址： [segmentfault.com/q/101000000…](
> https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fq%2F1010000009106416
> )
> 
> 

缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。

### 5.4 redis 和 memcached 的区别 ###

对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！

* **redis支持更丰富的数据类型（支持更复杂的应用场景）** ：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。
* **Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。**
* **集群模式** ：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是redis目前是原生支持cluster模式的，redis官方就是支持redis cluster集群模式的，比memcached来说要更好。
* **Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。**

> 
> 
> 
> 来自网络上的一张图，这里分享给大家！
> 
> 

![redis 和 memcached 的区别](https://user-gold-cdn.xitu.io/2018/9/25/1660ed1574f4977f?imageView2/0/w/1280/h/960/ignore-error/1)

### 5.5 redis 常见数据结构以及使用场景分析 ###

#### 1. String ####

> 
> 
> 
> **常用命令:** set,get,decr,incr,mget 等。
> 
> 

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。

#### 2.Hash ####

> 
> 
> 
> **常用命令：** hget,hset,hgetall 等。
> 
> 

Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：

` key=JavaUser293847 value={ “id”: 1, “name”: “SnailClimb”, “age”: 22, “location”: “Wuhan, Hubei” } 复制代码`

#### 3.List ####

> 
> 
> 
> **常用命令:** lpush,rpush,lpop,rpop,lrange等
> 
> 

list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。

Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。

#### 4.Set ####

> 
> 
> 
> **常用命令：** sadd,spop,smembers,sunion 等
> 
> 

set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。

当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。

比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：

` sinterstore key1 key2 key3 将交集存在key1内 复制代码`

#### 5.Sorted Set ####

> 
> 
> 
> **常用命令：** zadd,zrange,zrem,zcard等
> 
> 

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

**举例：** 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。

### 5.6 redis 设置过期时间 ###

Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

我们set key的时候，都可以给一个expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存货的时间。

如果假设你设置一个一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？

**定期删除+惰性删除。**

通过名字大概就能猜出这两个删除方式的意思了。

* **定期删除** ：redis默认是每隔 100ms 就 **随机抽取** 一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！
* **惰性删除** ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？

**redis 内存淘汰机制。**

### 5.7 redis 内存淘汰机制（MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？） ###

redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看： [download.redis.io/redis-stabl…]( https://link.juejin.im?target=http%3A%2F%2Fdownload.redis.io%2Fredis-stable%2Fredis.conf )

**redis 提供 6种数据淘汰策略：**

* **volatile-lru** ：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
* **volatile-ttl** ：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
* **volatile-random** ：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
* **allkeys-lru** ：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.
* **allkeys-random** ：从数据集（server.db[i].dict）中任意选择数据淘汰
* **no-enviction** ：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

**备注： 关于 redis 设置过期时间以及内存淘汰机制，我这里只是简单的总结一下，后面会专门写一篇文章来总结！**

### 5.8 redis 持久化机制（怎么保证 redis 挂掉之后再重启数据可以进行恢复） ###

很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。

Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。 **Redis的一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF）**.这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。

**快照（snapshotting）持久化（RDB）**

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。

快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：

` save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 复制代码`

**AOF（append-only file）持久化**

与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：

` appendonly yes 复制代码`

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。

在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

` appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘 appendfsync no #让操作系统决定何时进行同步 复制代码`

为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

**补充内容：AOF 重写**

AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。

AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任伺读入、分析或者写人操作。

在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作

**更多内容可以查看我的这篇文章：**

* [github.com/Snailclimb/…]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSnailclimb%2FJavaGuide%2Fblob%2Fmaster%2F%25E6%2595%25B0%25E6%258D%25AE%25E5%25AD%2598%25E5%2582%25A8%2FRedis%2FRedis%25E6%258C%2581%25E4%25B9%2585%25E5%258C%2596.md )

### 5.9 缓存雪崩和缓存穿透问题解决方案 ###

**缓存雪崩**

简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法（中华石杉老师在他的视频中提到过）：

* 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
* 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
* 事后：利用 redis 持久化机制保存的数据尽快恢复缓存

![](https://user-gold-cdn.xitu.io/2018/9/25/1660ed1572861c3c?imageView2/0/w/1280/h/960/ignore-error/1)

**缓存穿透**

简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

参考：

* [blog.csdn.net/zeb_perfect…]( https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fzeb_perfect%2Farticle%2Fdetails%2F54135506 ) [enter link description here]( https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fzeb_perfect%2Farticle%2Fdetails%2F54135506 )

### 5.10 如何解决 Redis 的并发竞争 Key 问题 ###

所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）

基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

在实践中，当然是从以可靠性为主。所以首推Zookeeper。

参考：

* [www.jianshu.com/p/8bddd381d…]( https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F8bddd381de06 )

### 5.11 如何保证缓存与数据库双写时的数据一致性？ ###

你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

**参考：**

* Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师。视频地址见下面！

* 链接： [pan.baidu.com/s/18pp6g1xK…]( https://link.juejin.im?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F18pp6g1xKVGCfUATf_nMrOA )
* 密码：5i58

# 六 Java #

### 6.1 Java 基础知识 ###

> 
> 
> 
> **重载和重写的区别**
> 
> 

**重载** ： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

**重写** ： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

> 
> 
> 
> **String 和 StringBuffer、StringBuilder 的区别是什么？String 为什么是不可变的？**
> 
> 

**可变性**

简单的来说：String 类中使用 final 关键字字符数组保存字符串， ` private&emsp;final&emsp;char&emsp;value[]` ，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 ` char[]value` 但是没有用 final 关键字修饰，所以这两种对象都是可变的。

StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。

AbstractStringBuilder.java

` abstract class AbstractStringBuilder implements Appendable , CharSequence { char [] value; int count; AbstractStringBuilder() { } AbstractStringBuilder( int capacity) { value = new char [capacity]; } 复制代码`

**线程安全性**

String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

* 操作少量的数据 = String
* 单线程操作字符串缓冲区下操作大量数据 = StringBuilder
* 多线程操作字符串缓冲区下操作大量数据 = StringBuffer

> 
> 
> 
> **自动装箱与拆箱**
> 
> 

**装箱** ：将基本类型用它们对应的引用类型包装起来；

**拆箱** ：将包装类型转换为基本数据类型；

> 
> 
> 
> **== 与 equals**
> 
> 

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

* 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
* 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。

**举个例子：**

` public class test1 { public static void main (String[] args) { String a = new String( "ab" ); // a 为一个引用 String b = new String( "ab" ); // b为另一个引用,对象的内容一样 String aa = "ab" ; // 放在常量池中 String bb = "ab" ; // 从常量池中查找 if (aa == bb) // true System.out.println( "aa==bb" ); if (a == b) // false，非同一对象 System.out.println( "a==b" ); if (a.equals(b)) // true System.out.println( "aEQb" ); if ( 42 == 42.0 ) { // true System.out.println( "true" ); } } } 复制代码`

**说明：**

* String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
* 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

> 
> 
> 
> **关于 final 关键字的一些总结**
> 
> 

final关键字主要用在三个地方：变量、方法、类。

* 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
* 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
* 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为fianl。

### 6.2 Java 集合框架 ###

> 
> 
> 
> **Arraylist 与 LinkedList 异同**
> 
> 

* **1. 是否保证线程安全：** ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；
* **2. 底层数据结构：** Arraylist 底层使用的是Object数组；LinkedList 底层使用的是双向循环链表数据结构；
* **3. 插入和删除是否受元素位置的影响：** ① **ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** 比如：执行 ` add(E e)` 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（ ` add(int index, E element)` ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② **LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。**
* **4. 是否支持快速随机访问：** LinkedList 不支持高效的随机元素访问，而ArrayList 实现了RandmoAccess 接口，所以有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象(对应于 ` get(int index)` 方法)。
* **5. 内存空间占用：** ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。

**补充：数据结构基础之双向链表**

双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表，如下图所示，同时下图也是LinkedList 底层使用的是双向循环链表数据结构。

![](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5c685eca3?imageView2/0/w/1280/h/960/ignore-error/1)

> 
> 
> 
> **ArrayList 与 Vector 区别**
> 
> 

Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。

Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。

> 
> 
> 
> **HashMap的底层实现**
> 
> 

**①JDK1.8之前**

JDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列** 。 **HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 ` (n - 1) & hash` 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**

**所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。**

**JDK 1.8 HashMap 的 hash 方法源码:**

JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。

` static final int hash (Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // >>>:无符号右移，忽略符号位，空位都以0补齐 return (key == null ) ? 0 : (h = key.hashCode()) ^ (h >>> 16 ); } 复制代码`

对比一下 JDK1.7的 HashMap 的 hash 方法源码.

` static int hash ( int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h >>> 20 ) ^ (h >>> 12 ); return h ^ (h >>> 7 ) ^ (h >>> 4 ); } 复制代码`

相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。

所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

![jdk1.8之前的内部结构](https://user-gold-cdn.xitu.io/2018/3/20/16240dbcc303d872?imageView2/0/w/1280/h/960/ignore-error/1)

**②JDK1.8之后**

相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。

![JDK1.8之后的HashMap底层数据结构](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5c63439c8?imageView2/0/w/1280/h/960/ignore-error/1)

> 
> 
> 
> TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
> 
> 
> 

**推荐阅读：**

* 《Java 8系列之重新认识HashMap》 ： [zhuanlan.zhihu.com/p/21673805]( https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F21673805 )

> 
> 
> 
> **HashMap 和 Hashtable 的区别**
> 
> 

* **线程是否安全：** HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 ` synchronized` 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；
* **效率：** 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；
* **对Null key 和Null value的支持：** HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。
* **初始容量大小和每次扩充容量大小的不同 ：** ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。
* **底层数据结构：** JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

> 
> 
> 
> **HashMap 的长度为什么是2的幂次方**
> 
> 

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483648，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。

**这个算法应该如何设计呢？**

我们首先可能会想到采用%取余的操作来实现。但是，重点来了： **“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。**

> 
> 
> 
> **HashMap 多线程操作导致死循环问题**
> 
> 

在多线程下，进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致环形链表。复制链表过程如下:
以下模拟2个线程同时扩容。假设，当前 HashMap 的空间为2（临界值为1），hashcode 分别为 0 和 1，在散列地址 0 处有元素 A 和 B，这时候要添加元素 C，C 经过 hash 运算，得到散列地址为 1，这时候由于超过了临界值，空间不够，需要调用 resize 方法进行扩容，那么在多线程条件下，会出现条件竞争，模拟过程如下：

线程一：读取到当前的 HashMap 情况，在准备扩容时，线程二介入

![](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5c20d7ba1?imageView2/0/w/1280/h/960/ignore-error/1)

线程二：读取 HashMap，进行扩容

![](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5c6d3569e?imageView2/0/w/1280/h/960/ignore-error/1)

线程一：继续执行

![](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5c1fe61b5?imageView2/0/w/1280/h/960/ignore-error/1)

这个过程为，先将 A 复制到新的 hash 表中，然后接着复制 B 到链头（A 的前边：B.next=A），本来 B.next=null，到此也就结束了（跟线程二一样的过程），但是，由于线程二扩容的原因，将 B.next=A，所以，这里继续复制A，让 A.next=B，由此，环形链表出现：B.next=A; A.next=B

> 
> 
> 
> **HashSet 和 HashMap 区别**
> 
> 

如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone() 方法、writeObject()方法、readObject()方法是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。）

![HashSet 和 HashMap 区别](https://user-gold-cdn.xitu.io/2018/3/2/161e717d734f3b23?imageView2/0/w/1280/h/960/ignore-error/1)

> 
> 
> 
> **ConcurrentHashMap 和 Hashtable 的区别**
> 
> 

ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。

* **底层数据结构：** JDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
* **实现线程安全的方式（重要）：** ① **在JDK1.7的时候，ConcurrentHashMap（分段锁）** 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） **到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② **Hashtable(同一把锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

**两者的对比图：**

图片来源： [www.cnblogs.com/chengxiao/p…]( https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fchengxiao%2Fp%2F6842045.html )

HashTable:

![](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5c6ce31a4?imageView2/0/w/1280/h/960/ignore-error/1)

JDK1.7的ConcurrentHashMap：

![](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5f65d740f?imageView2/0/w/1280/h/960/ignore-error/1) JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）： ![](https://user-gold-cdn.xitu.io/2018/9/22/165fe8e5f64960a2?imageView2/0/w/1280/h/960/ignore-error/1)

> 
> 
> 
> **ConcurrentHashMap线程安全的具体实现方式/底层具体实现**
> 
> 

**①JDK1.7（上面有示意图）**

首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

**ConcurrentHashMap 是由 Segment 数组结构和 HahEntry 数组结构组成** 。

Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。

` static class Segment < K , V > extends ReentrantLock implements Serializable { } 复制代码`

一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。

**②JDK1.8 （上面有示意图）**

ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。

synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。

> 
> 
> 
> **集合框架底层数据结构总结**
> 
> 

**Collection**

1.List

* 

**Arraylist：** Object数组

* 

**Vector：** Object数组

* 

**LinkedList：** 双向循环链表 2.Set

* 

**HashSet（无序，唯一）:** 基于 HashMap 实现的，底层采用 HashMap 来保存元素

* 

**LinkedHashSet：** LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。

* 

**TreeSet（有序，唯一）：** 红黑树(自平衡的排序二叉树。)

**Map**

* **HashMap：** JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间
* **LinkedHashMap:** LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看： [《LinkedHashMap 源码详细分析（JDK1.8）》]( https://link.juejin.im?target=https%3A%2F%2Fwww.imooc.com%2Farticle%2F22931 )
* **HashTable:** 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的
* **TreeMap:** 红黑树（自平衡的排序二叉树）

### 6.3 Java多线程 ###

关于 Java多线程，在面试的时候，问的比较多的就是 **①悲观锁和乐观锁** （ 具体可以看我的这篇文章： [面试必备之乐观锁与悲观锁]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSnailclimb%2FJava-Guide%2Fblob%2Fmaster%2F%25E9%259D%25A2%25E8%25AF%2595%25E5%25BF%2585%25E5%25A4%2587%2F%25E9%259D%25A2%25E8%25AF%2595%25E5%25BF%2585%25E5%25A4%2587%25E4%25B9%258B%25E4%25B9%2590%25E8%25A7%2582%25E9%2594%2581%25E4%25B8%258E%25E6%2582%25B2%25E8%25A7%2582%25E9%2594%2581.md ) ）、 **②synchronized和lock区别以及volatile和synchronized的区别** ， **③可重入锁与非可重入锁的区别** 、 **④多线程是解决什么问题的** 、 **⑤线程池解决什么问题** 、 **⑥线程池的原理** 、 **⑦线程池使用时的注意事项** 、 **⑧AQS原理、⑨ReentranLock源码，设计原理，整体过程** 等等问题。

面试官在多线程这一部分很可能会问你有没有在项目中实际使用多线程的经历。所以， 如果你在你的项目中有实际使用Java多线程的经历 的话，会为你加分不少哦！

### 6.4 Java虚拟机 ###

关于Java虚拟机，在面试的时候一般会问的大多就是 **①Java内存区域** 、 **②虚拟机垃圾算法** 、 **③虚拟机垃圾收集器** 、 **④JVM内存管理** 、 **⑤JVM调优** 这些问题了。    具体可以查看我的这两篇文章：

* [github.com/Snailclimb/…]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSnailclimb%2FJavaGuide%2Fblob%2Fmaster%2FJava%25E7%259B%25B8%25E5%2585%25B3%2F%25E5%258F%25AF%25E8%2583%25BD%25E6%2598%25AF%25E6%258A%258AJava%25E5%2586%2585%25E5%25AD%2598%25E5%258C%25BA%25E5%259F%259F%25E8%25AE%25B2%25E7%259A%2584%25E6%259C%2580%25E6%25B8%2585%25E6%25A5%259A%25E7%259A%2584%25E4%25B8%2580%25E7%25AF%2587%25E6%2596%2587%25E7%25AB%25A0.md )
* [github.com/Snailclimb/…]( https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FSnailclimb%2FJavaGuide%2Fblob%2Fmaster%2FJava%25E7%259B%25B8%25E5%2585%25B3%2F%25E5%258F%25AF%25E8%2583%25BD%25E6%2598%25AF%25E6%258A%258AJava%25E5%2586%2585%25E5%25AD%2598%25E5%258C%25BA%25E5%259F%259F%25E8%25AE%25B2%25E7%259A%2584%25E6%259C%2580%25E6%25B8%2585%25E6%25A5%259A%25E7%259A%2584%25E4%25B8%2580%25E7%25AF%2587%25E6%2596%2587%25E7%25AB%25A0.md )

### 6.5 设计模式 ###

设计模式比较常见的就是让你 **手写一个单例模式** （注意单例模式的几种不同的实现方法）或者让你说一下 **某个常见的设计模式在你的项目中是如何使用的** ，另外面试官还有可能问你 **抽象工厂和工厂方法模式的区别** 、 **工厂模式的思想** 这样的问题。

建议把 **代理模式** 、 **观察者模式** 、 **（抽象）工厂模式** 好好看一下，这三个设计模式也很重要。

# 七 数据结构 #

数据结构比较常问的就是： **二叉树** 、 **红黑树** （很可能让你手绘一个红黑树出来哦！）、 **二叉查找树（BST）** 、 **平衡二叉树（Self-balancing binary search tree）** 、 **B-树，B+树与B*树的优缺点比较** 、 **LSM 树** 这些知识点。

数据结构很重要，而且学起来也相对要难一些。建议学习数据结构一定要循序渐进的来，一步一个脚印的走好。一定要搞懂原理，最好自己能用代码实现一遍。

# 八 算法 #

**常见的加密算法、排序算法都需要自己提前了解一下，排序算法最好自己能够独立手写出来。**

我觉得面试中最刺激、最有压力或者说最有挑战的一个环节就是 **手撕算法** 了。面试中大部分算法题目都是来自于Leetcode、剑指offer上面，建议大家可以每天挤出一点时间刷一下算法题。

**推荐两个刷题必备网站：**

**LeetCode：**

* [LeetCode（中国）官网]( https://link.juejin.im?target=https%3A%2F%2Fleetcode-cn.com%2F )
* [如何高效地使用 LeetCode]( https://link.juejin.im?target=https%3A%2F%2Fleetcode-cn.com%2Farticles%2F%25E5%25A6%2582%25E4%25BD%2595%25E9%25AB%2598%25E6%2595%2588%25E5%259C%25B0%25E4%25BD%25BF%25E7%2594%25A8-leetcode%2F )

**牛客网：**

* [牛客网首页]( https://link.juejin.im?target=https%3A%2F%2Fwww.nowcoder.com )

### 8.1 举个栗子（手写快排） ###

面试官可能会问你，了解哪些排序方法啊？除了冒泡排序和选择排序能不能给我手写一个其他的排序算法。或者面试官可能会直接问你：“能不能给我手写一个快排出来？”。

**快排的基本思想：** 通过选择的参考值将待排序记录分割成独立的两部分，一部分全小于选取的参考值，另一部分全大于选取的参考值。对分割之后的部分再进行同样的操作直到无法再进行该操作位置(可以使用递归)。

下面是我写的一个简单的快排算法，我选择的参考值是数组的第一个元素。

` import java.util.Arrays; public class QuickSort { public static void main (String[] args) { // TODO Auto-generated method stub int [] num = { 1 , 3 , 4 , 8 , 5 , 10 , 22 , 15 , 16 }; QuickSort.quickSort(num, 0 , num.length - 1 ); System.out.println(Arrays.toString(num)); } public static void quickSort ( int [] a, int start, int end) { // 该值定义了从哪个位置开始分割数组 int ref; if (start < end) { // 调用partition方法对数组进行排序 ref = partition(a, start, end); // 对分割之后的两个数组继续进行排序 quickSort(a, start, ref - 1 ); quickSort(a, ref + 1 , end); } } /** * 选定参考值对给定数组进行一趟快速排序 * * @param a * 数组 * @param start * （切分）每个数组的第一个的元素的位置 * @param end * （切分）每个数组的最后一个的元素位置 * @return 下一次要切割数组的位置 */ public static int partition ( int [] a, int start, int end) { // 取数组的第一个值作为参考值（关键数据） int refvalue = a[start]; // 从数组的右边开始往左遍历，直到找到小于参考值的元素 while (start < end) { while (end > start && a[end] >= refvalue) { end--; } // 将元素直接赋予给左边第一个元素，即pivotkey所在的位置 a[start] = a[end]; // 从序列的左边边开始往右遍历，直到找到大于基准值的元素 while (end > start && a[start] <= refvalue) { start++; } a[end] = a[start]; return end; } // 最后的start是基准值所在的位置 a[start] = refvalue; return start; } } 复制代码`

**时间复杂度分析：**

* 在最优的情况下，Partition每次都划分得很均匀，快速排序算法的时间复杂度为O(nlogn)。
* 最糟糕情况下的快排，当待排序的序列为正序或逆序排列时，时间复杂度为O(n^2)。

**空间复杂度分析：**

* 最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)
* 最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。

**一种简单优化的方式：**

三向切分快速排序 ：核心思想就是将待排序的数据分为三部分,左边都小于比较值,右边都大于比较值,中间的数和比较值相等.三向切分快速排序的特性就是遇到和比较值相同时,不进行数据交换, 这样对于有大量重复数据的排序时,三向切分快速排序算法就会优于普通快速排序算法,但由于它整体判断代码比普通快速排序多一点,所以对于常见的大量非重复数据,它并不能比普通快速排序多大多的优势 。

# 九 Spring #

**Spring** 一般是不可避免的，如果你的简历上注明了你会 **Spring Boot** 或者 **Spring Cloud** 的话，那么面试官也可能会同时问你这两个技术,比如他可能会问你 **springboot和spring的区别。** **所以，一定要谨慎对待写在简历上的东西，一定要对简历上的东西非常熟悉。**

另外， **AOP实现原理** 、 **动态代理** 和 **静态代理** 、 **Spring IOC的初始化过程** 、 **IOC原理** 、 **自己怎么实现一个IOC容器？** 这些东西都是经常会被问到的。

### 9.1 Spring Bean 的作用域 ###

![](https://user-gold-cdn.xitu.io/2018/9/19/165ef64cb41273b8?imageView2/0/w/1280/h/960/ignore-error/1)

### 9.2 Spring 事务中的隔离级别 ###

TransactionDefinition 接口中定义了五个表示隔离级别的常量：

* **TransactionDefinition.ISOLATION_DEFAULT:** 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.
* **TransactionDefinition.ISOLATION_READ_UNCOMMITTED:** 最低的隔离级别，允许读取尚未提交的数据变更， **可能会导致脏读、幻读或不可重复读**
* **TransactionDefinition.ISOLATION_READ_COMMITTED:** 允许读取并发事务已经提交的数据， **可以阻止脏读，但是幻读或不可重复读仍有可能发生**
* **TransactionDefinition.ISOLATION_REPEATABLE_READ:** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改， **可以阻止脏读和不可重复读，但幻读仍有可能发生。**
* **TransactionDefinition.ISOLATION_SERIALIZABLE:** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说， **该级别可以防止脏读、不可重复读以及幻读** 。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

### 9.3 Spring 事务中的事务传播行为 ###

**支持当前事务的情况：**

* **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
* **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
* **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

**不支持当前事务的情况：**

* **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
* **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
* **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

* **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

### 9.4 AOP ###

AOP思想的实现一般都是基于 代理模式 ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，JDK动态代理模式只能代理接口而不能代理类。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。

* 如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；
* 如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。

这部分内容可以查看下面这几篇文章：

* [www.jianshu.com/p/fe8d1e8bd…]( https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Ffe8d1e8bd63e )
* [www.cnblogs.com/puyangsky/p…]( https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fpuyangsky%2Fp%2F6218925.html )
* [juejin.im/post/5a55af…]( https://juejin.im/post/5a55af9e518825734d14813f )

### 9.5 IOC ###

**Spring IOC的初始化过程：**

![Spring IOC的初始化过程](https://user-gold-cdn.xitu.io/2018/9/22/165fea36b569d4f4?imageView2/0/w/1280/h/960/ignore-error/1)

IOC源码阅读

* [javadoop.com/post/spring…]( https://link.juejin.im?target=https%3A%2F%2Fjavadoop.com%2Fpost%2Fspring-ioc )

# 十 实际场景题 #

我觉得实际场景题就是对你的知识运用能力以及思维能力的考察。建议大家在平时养成多思考问题的习惯，这样面试的时候碰到这样的问题就不至于慌了。另外，如果自己实在不会就给面试官委婉的说一下，面试官可能会给你提醒一下。切忌不懂装懂，乱答一气。      面试官可能会问你类似这样的问题：①假设你要做一个银行app，有可能碰到多个人同时向一个账户打钱的情况，有可能碰到什么问题，如何解决（锁）②你是怎么保证你的代码质量和正确性的？③下单过程中是下订单减库存还是付款减库存，分析一下两者的优劣；④同时给10万个人发工资，怎么样设计并发方案，能确保在1分钟内全部发完。⑤如果让你设计xxx系统的话，你会如何设计。

# 写在最后 #

**最后，再强调几点：**

* 一定要谨慎对待写在简历上的东西，一定要对简历上的东西非常熟悉。因为一般情况下，面试官都是会根据你的简历来问的；
* 能有一个上得了台面的项目也非常重要，这很可能是面试官会大量发问的地方，所以在面试之前好好回顾一下自己所做的项目；
* 和面试官聊基础知识比如设计模式的使用、多线程的使用等等，可以结合具体的项目场景或者是自己在平时是如何使用的；
* 注意自己开源的Github项目，面试官可能会挖你的Github项目提问；
* 建议提前了解一下自己想要面试的公司的价值观，判断一下自己究竟是否适合这个公司。

另外，我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！

初次之外，笔主也在这里给自己挖一个坑，关于 dubbo、zookeeper 等内容我会在后续做一个系统总结。保证大家看了之后，一定有收获！

最后，附上 [征文链接]( https://juejin.im/post/5b923adb5188255c6666c77b?utm_medium=qzarticle&utm_source=zhengwen ) 。

还有三个本次活动的合作伙伴：

![](https://user-gold-cdn.xitu.io/2018/9/27/16619ce661860512?imageView2/0/w/1280/h/960/ignore-error/1)