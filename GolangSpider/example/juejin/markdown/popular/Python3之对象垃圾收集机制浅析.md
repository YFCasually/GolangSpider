# Python3之对象垃圾收集机制浅析 #

###概述 GC作为现代编程语言的自动内存管理机制，专注于两件事：1. 找到内存中无用的垃圾资源 2. 清除这些垃圾并把内存让出来给其他对象使用。 在Python中，它在每个对象中保持了一个计数器，用于记录指向该对象的的引用的个数。一旦这个计数器为0时，则立即回收该对象，对象占用的内存空间将被释放。

### 引用计数 ###

我们可以利用简单的变量引用和销毁窥见引用计数过程。

#### 增加引用计数 ####

增加引用计数的方式多种，即对象进行引用，那么计数器都会+1

` # 创建第一个引用 a = 3 # 用其他变量名引用 b = a # 成为一个容器的对象 L = [ 1 , a] # 作为参数传递 str(a) 复制代码`

#### 减少引用计数 ####

同理，以下是减少引用计数的一些方法

` # 一个本地引用离开了其作用范围。比如`str()`函数结束时 str(a) # 对象的别名被显式销毁 del a # 对象的一个别名被复制给其他对象 a = 'Python' # 对象从一个窗口对象中移除 L.remove(a) # 窗口对象本身被销毁 del L 复制代码`

### 循环引用问题 ###

什么是循环引用？A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数虽然都为1，但显然应该被回收。

` # 对象a的引用计数为 1 a = {} # 对象B的引用计数为 1 b = {} # B的引用计数增1 a[ 'b' ] = b # A的引用计数增1 b[ 'a' ] = a # A的引用减 1，最后A对象的引用为 1 del a # B的引用减 1, 最后B对象的引用为 1 del b 复制代码`

在这个例子中程序执行完del语句后，A、B对象已经没有任何引用指向这两个对象，但这两个对象却还各自引用这对象，虽然两个对象已经被 ` del` 了，即我们不能再使用这两个对象，即垃圾对象，但是他们的引用计数并没有减少到零。即根据引用计数机制，他们并不会被回收，且会一直驻留在内存中，造成内存泄漏。为了解决对象的循环引用问题，而Python引入了 **标记-清除** 和 **分代回收** 两种GC机制来解决优化此问题。