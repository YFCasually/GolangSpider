# Java：锁的四中状态：无锁，偏向锁，轻量级锁，重量级锁 #

Java并发编程，自己在实际项目确实很少用到，经常学了就忘，忘了在学的恶心循环。通过再次的学习，掌握一些并发编程原理和理清经常混淆的知识点。

### synchronized ###

synchronized,所谓的重量级锁。Java中每一个对象都可以作为一个锁，表现为：

* 对于普通方法的同步，锁是当前实例对象。
* 对于静态方法的同步，锁是当前类的Class对象。
* 对于同步方法块，锁是Synchronized括号里配置的对象。

jVM基于进入和退出Monitor对象来实现方法同步和代码同步。方法同步是使用monitorenter和monitorexit指令实现的，monitorenter指令是在编译后插入到同步代码块开始的位置，monitorexit是插在方法结束处和异常处。方法同步使用另一种实现方式，在JVM规范里没有详细的说明。

### volatile ###

volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的 **可见性** 。对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入，对单个volatile变量的读写具有原子性。就是说，线程对volatile变量本地内存的写入会被更新到主内存，其他线程对同个volatile的读取，会先将本地的设为无效，必须从主内存中读取。

### 锁的状态 ###

#### 锁是存在哪里的呢？ ####

锁存在Java的对象头中的Mark Work。Mark Work默认不仅存放着锁标志位，还存放对象hashCode等信息。运行时，会根据 **锁的状态，修改Mark Work的存储内容** 。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。关于对象头等相关知识，可以参考Java虚拟机相关文章。

32位JVM默认状态下Mark Work的存储结构。

![](https://user-gold-cdn.xitu.io/2019/5/30/16b06e3723e4513d?imageView2/0/w/1280/h/960/ignore-error/1) 32位JVM运行状态下，Mark Work的存储结构。 ![运行情况下32位JVM的Mark Work](https://user-gold-cdn.xitu.io/2019/5/30/16b06e0c8d6c4577?imageView2/0/w/1280/h/960/ignore-error/1)

#### 锁的状态 ####

**锁有四种状态：无锁状态、偏向锁、轻量级锁、重量级锁**

随着锁的竞争，锁的状态会从偏向锁到轻量级锁，再到重量级锁。而且锁的状态只有升级，没有降级。也就是只有偏向锁->轻量级锁->重量级锁，没有重量级锁->轻量级锁->偏向锁。

+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------+
|  锁名称  |                                                                                                                   描述                                                                                                                   |        应用场景        |
+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------+
| 偏向锁   | 线程在大多数情况下并不存在竞争条件，使用同步会消耗性能，而偏向锁是对锁的优化，可以消除同步，提升性能。当一个线程获得锁，会将对象头的锁标志位设为01,进入偏向模式.偏向锁可以在让一个线程一直持有锁，在其他线程需要竞争锁的时候，再释放锁。 | 只有一个线程进入临界区 |
| 轻量级锁 | 当线程A获得偏向锁后，线程B进入竞争状态，需要获得线程A持有的锁，那么线程A撤销偏向锁，进入无锁状态。线程A和线程B交替进入临界区，偏向锁无法满足，膨胀到轻量级锁，锁标志位设为00。                                                           | 多个线程交替进入临界区 |
| 重量级锁 | 当多线程交替进入临界区，轻量级锁hold得住。但如果多个线程同时进入临界区，hold不住了，膨胀到重量级锁                                                                                                                                       | 多个线程同时进入临界区 |
+----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------+

#### 锁的优缺点 ####

+----------+------------------------------------------------------------------+--------------------------------------------------+--------------------------------------+
|    锁    |                               优点                               |                       缺点                       |               适用场景               |
+----------+------------------------------------------------------------------+--------------------------------------------------+--------------------------------------+
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                       | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                                  | 线程阻塞，响应时间缓慢                           | 追求吞吐量。同步块执行速度较长。     |
+----------+------------------------------------------------------------------+--------------------------------------------------+--------------------------------------+

### 总结 ###

在锁的状态中，主要是理解什么是偏向锁，轻量级锁，重量级，以及他们的应用场景。

![点个赞，老铁](https://user-gold-cdn.xitu.io/2019/5/30/16b06891c7562a34?imageView2/0/w/1280/h/960/format/png/ignore-error/1)

如果觉得文章有用，给文章点个赞，铁子

本文是个人学习总结和知识备忘，如知识有误或片面，请多加指正，谢谢

知识来源《Java并发编程的艺术》